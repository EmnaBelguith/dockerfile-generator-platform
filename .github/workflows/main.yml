# .github/workflows/main.yml
# Nom du workflow qui apparaîtra dans l'onglet "Actions" de GitHub
name: Docker Build, Push and Test Flask App

# Déclencheurs du workflow
on:
  push:
    branches:
      - main
  workflow_dispatch:

# Définition des jobs (tâches) à exécuter
jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        run: |
          # Remplace 'emna1belghith' par ton nom d'utilisateur Docker Hub exact
          # Le '.' à la fin indique que le Dockerfile se trouve dans le répertoire courant (racine du dépôt)
          IMAGE_NAME=emna1belghith/python-docker-app
          IMAGE_TAG=${{ github.sha }} # Utilise le SHA du commit comme tag unique
          
          docker build -t $IMAGE_NAME:$IMAGE_TAG .
          docker push $IMAGE_NAME:$IMAGE_TAG
          
          # Optionnel: Pousser aussi avec le tag 'latest'
          docker tag $IMAGE_NAME:$IMAGE_TAG $IMAGE_NAME:latest
          docker push $IMAGE_NAME:latest

  # Nouveau job : Tester l'image Docker pour l'application Flask
  test-image:
    needs: build-and-publish # Ce job ne s'exécute que si le job précédent a réussi
    runs-on: ubuntu-latest

    steps:
      - name: Pull Docker image
        run: |
          IMAGE_NAME=emna1belghith/python-docker-app
          IMAGE_TAG=${{ github.sha }}
          docker pull $IMAGE_NAME:$IMAGE_TAG
          echo "Image $IMAGE_NAME:$IMAGE_TAG pulled successfully."

      - name: Run Docker container for testing Flask app
        id: run_container # Ajoute un ID pour référencer cette étape
        run: |
          IMAGE_NAME=emna1belghith/python-docker-app
          IMAGE_TAG=${{ github.sha }}
          # CORRECTION CLÉ ICI : Mappe le port 8080 du runner au port 5000 du conteneur (où Flask écoute)
          docker run -d --name test-app -p 8080:5000 $IMAGE_NAME:$IMAGE_TAG
          echo "Conteneur 'test-app' démarré sur le port 8080 du runner (mappé au port 5000 du conteneur)."
          echo "container_id=$(docker ps -aqf "name=test-app")" >> $GITHUB_OUTPUT

      - name: Wait for Flask application to start
        run: |
          echo "Attente du démarrage de l'application Flask..."
          # L'URL de test doit pointer vers le port 8080 du runner
          HEALTH_URL="http://localhost:8080/" 
          MAX_RETRIES=15 # Nombre maximal de tentatives
          RETRY_DELAY=5  # Délai entre les tentatives en secondes
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Tentative $i/$MAX_RETRIES: Vérification de $HEALTH_URL"
            # curl --fail: échoue si le code HTTP n'est pas 2xx
            # -s: mode silencieux
            RESPONSE=$(curl --fail -s $HEALTH_URL)
            if [[ "$?" -eq 0 ]]; then # Vérifie si curl a réussi (code de retour 0)
              echo "Application est saine et répond !"
              # Vérifie si la réponse contient le texte spécifique de Flask
              if [[ "$RESPONSE" == *"Hello from Flask!"* ]]; then
                echo "Test réussi : 'Hello from Flask!' trouvé dans la réponse."
                exit 0 # Succès, sortir de la boucle
              else
                echo "Test échoué : Attendu 'Hello from Flask!' mais obtenu '$RESPONSE'."
                exit 1 # Fait échouer le job GitHub Actions
              fi
            else
              echo "Application pas encore prête ou erreur de connexion. Nouvelle tentative dans $RETRY_DELAY secondes..."
              sleep $RETRY_DELAY
            fi
          done
          echo "L'application n'est pas devenue saine dans le délai imparti. Vérifiez les logs du conteneur pour les erreurs."
          docker logs test-app # Affiche les logs du conteneur avant d'échouer
          exit 1 # Fait échouer le job GitHub Actions si l'application ne démarre pas

      - name: Clean up Docker container
        if: always() # S'exécute toujours, même si les étapes précédentes échouent
        run: |
          echo "Arrêt et suppression du conteneur 'test-app'..."
          docker stop test-app || true # '|| true' pour ne pas échouer si le conteneur n'existe pas
          docker rm test-app || true
          echo "Conteneur nettoyé."
